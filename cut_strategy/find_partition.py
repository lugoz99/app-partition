import networkx as nx
from cut_strategy.graph import GraphManager
from cut_strategy.emd_calculation import EMDEvaluator
from cut_strategy.utils import Utils as utils


class PartitionFinder:
    """
    Encapsulates functionality to find the best partition in a graph by minimizing loss.
    """

    def __init__(self, network: GraphManager, process_data: dict, original_prob):
        self.network = network
        self.process_data = process_data
        self.original_prob = original_prob
        self.best_solutions = []
        self.graphs_to_evaluate = [network]
        self.best_solution_graph = None

    def find_best_partition(self):
        """
        Finds the best partition by iteratively evaluating graph partitions.

        Returns:
            GraphManager: The graph with the best partition found.
        """
        self.network.loss_value = 0
        self.process_data["val_cup"] = self._calculate_cut_value()

        while self.graphs_to_evaluate:
            current_graph = self.graphs_to_evaluate.pop(0)
            sorted_edges = self._get_sorted_edges(current_graph)

            new_graphs = self._evaluate_edges(current_graph, sorted_edges)
            self.graphs_to_evaluate.extend(new_graphs)

        return self.best_solution_graph

    def _calculate_cut_value(self):
        """
        Calculates the initial cut-off value based on edge weights and current channels.

        Returns:
            float: Initial cut-off value.
        """
        total_weight = sum(
            data["weight"] for _, _, data in self.network.edges(data=True)
        )
        num_channels = len(self.process_data["current"])
        return round((total_weight / len(self.network.edges())) * num_channels, 3)

    def _get_sorted_edges(self, graph: GraphManager):
        """
        Sorts edges in the graph by their weight.

        Args:
            graph (GraphManager): The graph whose edges are to be sorted.

        Returns:
            list: Sorted list of edges.
        """
        return sorted(graph.edges(data=True), key=lambda x: x[2]["weight"])

    def _evaluate_edges(self, graph: GraphManager, edges):
        """
        Evaluates and processes graph partitions by removing edges.

        Args:
            graph (GraphManager): The graph being evaluated.
            edges (list): List of edges to evaluate.

        Returns:
            list: New graphs generated by removing edges.
        """
        new_graphs = []

        for edge in edges:
            candidate_graph = self._create_candidate_graph(graph, edge)

            if not nx.is_connected(candidate_graph):
                self._process_solution(candidate_graph)
            else:
                self._process_candidate(candidate_graph, new_graphs)

        return new_graphs

    def _create_candidate_graph(self, graph: GraphManager, edge):
        """
        Creates a new graph by removing an edge and recalculating probabilities.

        Args:
            graph (GraphManager): Original graph.
            edge (tuple): Edge to be removed.

        Returns:
            GraphManager: New graph with updated probabilities.
        """
        new_graph = graph.copy()
        new_graph.remove_edge(edge[0], edge[1])
        new_graph.removed_edges.append(edge)

        new_probabilities = EMDEvaluator.calculate_new_probabilities(
            new_graph, self.process_data, edge
        )
        new_graph.table_probability = new_probabilities
        new_graph.loss_value = EMDEvaluator.calculate_emd(
            new_probabilities, self.process_data["state"], self.original_prob
        )

        return new_graph

    def _process_solution(self, graph: GraphManager):
        """
        Processes a graph that is no longer connected, potentially updating the best solution.

        Args:
            graph (GraphManager): Disconnected graph to evaluate as a solution.
        """
        if graph.loss_value < self.process_data["val_cup"]:
            self.best_solutions.append(graph)
            self.process_data["val_cup"] = graph.loss_value
            self.best_solution_graph = graph

    def _process_candidate(self, graph: GraphManager, new_graphs):
        """
        Adds a candidate graph to the list of graphs to evaluate if it meets the criteria.

        Args:
            graph (GraphManager): Candidate graph.
            new_graphs (list): List of graphs to evaluate.
        """
        if graph.loss_value < self.process_data["val_cup"]:
            new_graphs.append(graph)
